// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// -------- //
// iot_sram //
// -------- //

#define iot_sram_wrap_target 0
#define iot_sram_wrap 15

static const uint16_t iot_sram_program_instructions[] = {
            //     .wrap_target
    0x6820, //  0: out    x, 32           side 1     
    0x6840, //  1: out    y, 32           side 1     
    0xe88f, //  2: set    pindirs, 15     side 1     
    0x6004, //  3: out    pins, 4         side 0     
    0x1043, //  4: jmp    x--, 3          side 2     
    0x106e, //  5: jmp    !y, 14          side 2     
    0xe080, //  6: set    pindirs, 0      side 0     
    0xb0c3, //  7: mov    isr, null       side 2     
    0xf027, //  8: set    x, 7            side 2     
    0xa042, //  9: nop                    side 0     
    0x1049, // 10: jmp    x--, 9          side 2     
    0x4004, // 11: in     pins, 4         side 0     
    0x108b, // 12: jmp    y--, 11         side 2     
    0xb842, // 13: nop                    side 3     
    0xa8c3, // 14: mov    isr, null       side 1     
    0x0800, // 15: jmp    0               side 1     
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program iot_sram_program = {
    .instructions = iot_sram_program_instructions,
    .length = 16,
    .origin = -1,
};

static inline pio_sm_config iot_sram_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + iot_sram_wrap_target, offset + iot_sram_wrap);
    sm_config_set_sideset(&c, 2, false, false);
    return c;
}

static inline void iot_sram_program_init( PIO pio, uint32_t sm, uint32_t offset, uint32_t dat_base , uint32_t dat_pin_num, uint32_t signal_base, uint32_t signal_pin_num)
{
    /* 
     (MSB)<--- {nCS,SCLK,D3,D2,D1,D0} --->(LSB)
     dat_base : D[3:0]
     sig_base : {nCS,SCLK}
    */
    pio_sm_config c = iot_sram_program_get_default_config( offset );
    sm_config_set_out_pins( &c, dat_base, dat_pin_num);     // D[3:0]
    sm_config_set_in_pins( &c, dat_base );                  // D[3:0]
    sm_config_set_set_pins(&c, dat_base, dat_pin_num);
    sm_config_set_sideset_pins(&c, signal_base);            // {nCS,SCLK}
    sm_config_set_in_shift( &c, false, true, 32);
    sm_config_set_out_shift( &c, false, true, 32);          //auto pull
    {
        uint32_t pin_offset;
        for ( pin_offset = 0; pin_offset < dat_pin_num; pin_offset++ )
        {
            pio_gpio_init( pio, dat_base + pin_offset );
        }
        for ( pin_offset = 0; pin_offset < signal_pin_num; pin_offset++ )
        {
            pio_gpio_init( pio, signal_base + pin_offset );
        }
    }
    pio_sm_set_consecutive_pindirs( pio, sm, dat_base, dat_pin_num, true );
    pio_sm_set_consecutive_pindirs( pio, sm, signal_base, signal_pin_num, true );
    uint32_t dat_mask = 0x0f;                                   // D[3:0] = 0b1111
    pio_sm_set_pindirs_with_mask(pio, sm, dat_mask, dat_mask );
    sm_config_set_clkdiv( &c, 1);
    pio_sm_init( pio, sm, offset, &c );
    pio_sm_set_enabled( pio, sm, true );
}

#endif

