// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ----------- //
// ezspi_slave //
// ----------- //

#define ezspi_slave_wrap_target 0
#define ezspi_slave_wrap 9

static const uint16_t ezspi_slave_program_instructions[] = {
            //     .wrap_target
    0x6020, //  0: out    x, 32                      
    0xe047, //  1: set    y, 7                       
    0x2021, //  2: wait   0 pin, 1                   
    0x2022, //  3: wait   0 pin, 2                   
    0x6001, //  4: out    pins, 1                    
    0x20a2, //  5: wait   1 pin, 2                   
    0x0083, //  6: jmp    y--, 3                     
    0x0041, //  7: jmp    x--, 1                     
    0x20a1, //  8: wait   1 pin, 1                   
    0x0000, //  9: jmp    0                          
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program ezspi_slave_program = {
    .instructions = ezspi_slave_program_instructions,
    .length = 10,
    .origin = -1,
};

static inline pio_sm_config ezspi_slave_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + ezspi_slave_wrap_target, offset + ezspi_slave_wrap);
    return c;
}

static inline void ezspi_slave_program_init( PIO pio, uint32_t sm, uint32_t offset, uint32_t in_base , uint32_t in_pin_num, uint32_t out_base, uint32_t out_pin_num)
{
    /* 
     (MSB)<--- {nCS,SCLK,D3,D2,D1,D0} --->(LSB)
     dat_base : D[3:0]
     sig_base : {nCS,SCLK}
    */
    pio_sm_config c = ezspi_slave_program_get_default_config( offset );
    sm_config_set_out_pins( &c, out_base, out_pin_num);     // TX
    sm_config_set_in_pins( &c, in_base );                  // CLK,nCS,RX
    sm_config_set_in_shift( &c, false, true, 32);
    sm_config_set_out_shift( &c, false, true, 32);          //auto pull
    {
        uint32_t pin_offset;
        for ( pin_offset = 0; pin_offset < in_pin_num; pin_offset++ )
        {
            pio_gpio_init( pio, in_base + pin_offset );
        }
        for ( pin_offset = 0; pin_offset < out_pin_num; pin_offset++ )
        {
            pio_gpio_init( pio, out_base + pin_offset );
        }
    }
    pio_sm_set_consecutive_pindirs( pio, sm, out_base, out_pin_num, true );
    pio_sm_set_consecutive_pindirs( pio, sm, in_base, in_pin_num,  false );
    // uint32_t dat_mask = 0x03;                                   // D[3:0] = 0b0111
    // pio_sm_set_pindirs_with_mask(pio, sm, dat_mask, dat_mask );
    sm_config_set_clkdiv( &c, 1);
    pio_sm_init( pio, sm, offset, &c );
    pio_sm_set_enabled( pio, sm, true );
}

#endif

